///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
///<reference path="Arrays.ts"/>

import Literal = Interpreter.Literal;
import InterpretationResult = Interpreter.InterpretationResult;

/**
 * Planner module
 *
 * The goal of the Planner module is to take the interpetation(s)
 * produced by the Interpreter module and to plan a sequence of actions
 * for the robot to put the world into a state compatible with the
 * user's command, i.e. to achieve what the user wanted.
 *
 * The planner should use your A* search implementation to find a plan.
 */
module Planner {

  ////////////////////////////////////////////////////////////////////////////
  //            Exported functions, classes and interfaces/types            //
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Top-level driver for the Planner. Calls `planInterpretation` for each given
   * interpretation generated by the Interpreter.
   * @param  {InterpretationResult[]} interpretations list of possible
   *                                                  interpretations
   * @param  {WorldState}             currentState    the current state of the
   *                                                  world
   * @return {PlannerResult[]}                        Augments
   *         																					InterpretationResult with
   *         																					a plan represented by a
   *         																					list of strings
   */
  export function plan(
    interpretations : InterpretationResult[],
    currentState : WorldState
  ) : PlannerResult[] {
    let errors : Error[] = [];
    let plans : PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        let result : PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch(err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan : string[];
  }

  export function stringify(result : PlannerResult) : string {
    return result.plan.join(", ");
  }

  ////////////////////////////////////////////////////////////////////////////
  //                           Private functions                            //
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Indicates whether a given literal holds in a given world state.
   * @param  {Literal}    literal the literal
   * @param  {WorldState} state   the world state
   * @return {boolean}            true if the literal holds, false otherwise
   */
  function literalHolds(literal: Literal, state: WorldState): boolean {
    switch (literal.relation) {
      case 'holding':
        return state.holding == literal.args[0];
      case 'ontop':
        if (literal.args[1] == 'floor') {
          for (let stack of state.stacks)
            if (stack.indexOf(literal.args[0]) == 0)
              return true;
          return false;
        }

        for (let stack of state.stacks)
          if (stack.indexOf(literal.args[0])
              == stack.indexOf(literal.args[1]) - 1)
            return true;
        return false;
      case 'inside':
        // Same as 'ontop' since it is already checked by the interpreter
        for (let stack of state.stacks)
          if (stack.indexOf(literal.args[0])
              == stack.indexOf(literal.args[1]) - 1)
            return true;
        return false;
      case 'above':
        if (literal.args[1] == 'floor')
          return true;
        for (let stack of state.stacks)
          if (stack.indexOf(literal.args[0]) > stack.indexOf(literal.args[1]))
            return true;
        return false;
      case 'under':
        for (let stack of state.stacks)
          if (stack.indexOf(literal.args[0]) < stack.indexOf(literal.args[1]))
            return true;
        return false;
      case 'beside':
        for (let x = 0; x < state.stacks.length; x++)
          if (state.stacks[x].indexOf(literal.args[0]) > -1)
            return (x >= 1
                    && state.stacks[x - 1].indexOf(literal.args[1]) > -1)
                || (x < state.stacks.length - 1
                    && state.stacks[x + 1].indexOf(literal.args[1]) > -1)
        return false;
      case 'leftof':
        for (let x = 0; x < state.stacks.length; x++)
          if (state.stacks[x].indexOf(literal.args[0]) > -1)
            for (let x2 = x + 1; x2 < state.stacks.length; x2++)
              if (state.stacks[x2].indexOf(literal.args[1]) > -1)
                return true;
        return false;
      case 'rightof':
        for (let x = 0; x < state.stacks.length; x++)
          if (state.stacks[x].indexOf(literal.args[0]) > -1)
            for (let x2 = x - 1; x2 >= 0; x2--)
              if (state.stacks[x2].indexOf(literal.args[1]) > -1)
                return true;
        return false;
    }

    return false;
  }

  /**
   * Returns the position of a given object in a given world state.
   * @param  {string}     objectId the object
   * @param  {WorldState} state    the world state
   * @return {number[]}            a list containing two elements: a stack index
   *                               and a position in a stack
   */
  function getPosition(objectId: string, state: WorldState): number[] {
    for (let x = 0; x < state.stacks.length; x++) {
      let y: number = state.stacks[x].indexOf(objectId)

      if (y > -1)
        return [x, y];
    }

    throw Error("ERROR: Object '" + objectId + "' does not exist.");
  }

  /**
   * Returns the distance of a given object from the arm in the given world
   * state.
   * @param  {string}     objectId the object
   * @param  {WorldState} state    the world state
   * @return {number}              the distance of the object from the arm
   */
  function distanceFromArm(objectId: string, state: WorldState): number {
    return Math.abs(getPosition(objectId, state)[0] - state.arm);
  }

  /**
   * Returns the number of objects above a given object in a given world state.
   * @param  {string}     objectId the object
   * @param  {WorldState} state    the world state
   * @return {number}              the number of objects above the object
   */
  function objectsAbove(objectId: string, state: WorldState): number {
    let position: number[] = getPosition(objectId, state);

    return state.stacks[position[0]].length - position[1] - 1;
  }

  /**
   * Returns the estimate cost of a given literal. The estimate cost is
   * computed using the distance of the object and potentially the target from
   * the arm. The number of objects above the object to move/take might also
   * be used as well as the number of objects above the target.
   * @param  {Literal}    literal the literal
   * @param  {WorldState} state   the world state
   * @return {number}             an estimation of the cost to move/take an
   *                              object
   */
  function estimatedCostLiteral(literal: Literal, state: WorldState): number {
    if (literalHolds(literal, state))
      return 0;

    if (literal.relation == 'holding') {
      return (state.holding.length == 0 ? 1 : 2)
          + distanceFromArm(literal.args[0], state);
    } else {
      if (literal.relation == 'ontop' || literal.relation == 'inside') {
        return (state.holding.length == 0 ? 1 : 2)
            + (objectsAbove(literal.args[0], state) * 3)
            + distanceFromArm(literal.args[0], state)
            + (objectsAbove(literal.args[1], state) * 3)
            + distanceFromArm(literal.args[1], state);
      } else if (literal.relation == 'above') {
        return (state.holding.length == 0 ? 1 : 2)
            + (objectsAbove(literal.args[0], state) * 3)
            + distanceFromArm(literal.args[0], state)
            + distanceFromArm(literal.args[1], state);
      } else if (literal.relation == 'under') {
        return (state.holding.length == 0 ? 6 : 8)
            + (objectsAbove(literal.args[0], state) * 3)
            + distanceFromArm(literal.args[0], state)
            + (objectsAbove(literal.args[1], state) * 3)
            + distanceFromArm(literal.args[1], state);
      } else if (literal.relation == 'beside') {
        return (state.holding.length == 0 ? 1 : 2)
            + (objectsAbove(literal.args[0], state) * 3)
            + (distanceFromArm(literal.args[0], state))
            + (distanceFromArm(literal.args[1], state) - 1);
      } else if (literal.relation == 'leftof') {
        return (state.holding.length == 0 ? 1 : 2)
            + (objectsAbove(literal.args[0], state) * 3)
            + distanceFromArm(literal.args[0], state)
            + Math.abs(
                getPosition(literal.args[1], state)[0] + 1 - state.arm);
      } else if (literal.relation == 'rightof') {
        return (state.holding.length == 0 ? 1 : 2)
            + (objectsAbove(literal.args[0], state) * 3)
            + distanceFromArm(literal.args[0], state)
            + Math.abs(
                getPosition(literal.args[1], state)[0] - 1 - state.arm);
      }
    }

    return 0;
  }

  /**
   * Represents a node in a StateGraph. A StateNode has a world state and a move
   * that leads to this state.
   */
  class StateNode {
    /**
     * Constructs a new StateNode.
     * @param  {string}     move  a move
     * @param  {WorldState} state a world state
     */
    constructor (move: string, state: WorldState) { }

    move: string;
    state: WorldState;

    /**
     * Indicates whether the node is a goal node (i.e. the given interpretation
     * holds in its world state).
     * @param  {DNFFormula} interpretation the interpretation
     * @return {boolean}                   true if the node is a goal node,
     *                                     false otherwise
     */
    isGoal(interpretation: DNFFormula): boolean {
      return anyValue(interpretation, conjunction =>
          allValues(conjunction, literal =>
              literalHolds(literal, this.state)));
    }

    /**
     * Returns a heuristic for the node using a given interpretation. In order
     * to compute the heuristic, the function computes all possible heuristics
     * for all possible conjunctions and gets the lowest one (so that it is
     * never greater than the actual cost).
     * @param  {DNFFormula} interpretation the interpretation
     * @return {number}                    the heuristic
     */
    heuristic(interpretation: DNFFormula): number {
      return Math.min.apply(null, interpretation.map(conjunction =>
          Math.max.apply(null, conjunction.map(literal =>
              estimatedCostLiteral(literal, this.state)))));
    }
  }

  /**
   * Represents the graph used by the search algorithm. The graph is build on
   * the fly by the search algorithm.
   */
  class StateGraph implements Graph<StateNode> {
    // TODO Return all possible moves (on the fly)
    // Niklas
    outgoingEdges(node: StateNode): Edge<StateNode>[] {
      return null;
    }

    compareNodes: ICompareFunction<StateNode> = function (first, second) {
      // Unneeded
      return 0;
    }
  }

  /**
   * The core planner function. The code here is just a template;
   * you should rewrite this function entirely. In this template,
   * the code produces a dummy plan which is not connected to the
   * argument `interpretation`, but your version of the function
   * should be such that the resulting plan depends on
   * `interpretation`.
   *
   *
   * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
   * @param state The current world state.
   * @returns Basically, a plan is a
   * stack of strings, which are either system utterances that
   * explain what the robot is doing (e.g. "Moving left") or actual
   * actions for the robot to perform, encoded as "l", "r", "p", or
   * "d". The code shows how to build a plan. Each step of the plan can
   * be added using the `push` method.
   */
  function planInterpretation(
    interpretation: DNFFormula,
    state: WorldState
  ): string[] {
    let result: SearchResult<StateNode> = aStarSearch(
      new StateGraph(),
      new StateNode('', state),
      node => node.isGoal(interpretation),
      node => node.heuristic(interpretation),
      5
    );

    return result.path.map(node => node.move);
  }

  function getPossibleMoves(state: WorldState): string[] {
    let possibleMoves: string[] = [];

    if (state.holding.length == 0) {
      possibleMoves.push('p');
    } else if (canDrop(state)) {
      possibleMoves.push('d');
    }

    if (state.arm > 0)
      possibleMoves.push('l');

    if (state.arm < state.stacks.length)
      possibleMoves.push('r');

    return possibleMoves;
  }

  // Dominik
  function canDrop(state: WorldState): boolean {
    if(state.holding.length == 0)
      return false;
    // Balls must be in boxes or on the floor, otherwise they roll away.
    if(state.objects[state.holding].form == 'ball' &&
      state.stacks[state.arm].length != 0 &&
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].form != 'box')
      return false;
    // Balls cannot support anything.
    if(state.stacks[state.arm].length > 0 &&
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].form == 'ball')
      return false;
    // Small objects cannot support large objects.
    if(state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].size == 'small' &&
      state.objects[state.holding].size == 'large')
      return false;
    // Boxes cannot contain pyramids, planks or boxes of the same size.
    if(state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].form == 'box' &&
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].size == state.objects[state.holding].size &&
      (state.objects[state.holding].form == 'pyramid' || state.objects[state.holding].form == 'plank'
      || state.objects[state.holding].form == 'box'))
      return false;
    // Small boxes cannot be supported by small bricks or pyramids.
    if(state.objects[state.holding].form == 'box' && state.objects[state.holding].size == 'small' &&
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].size == 'small' &&
      (state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].form == 'brick' ||
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].form == 'pyramid'))
      return false;
    // Large boxes cannot be supported by large pyramids.
    if(state.objects[state.holding].form == 'box' && state.objects[state.holding].size == 'large' &&
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].form == 'pyramid' &&
      state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]].size == 'large')
      return false;
    return true;
  }

  // Dominik
  function newWorldState(state: WorldState, move: string): WorldState {
    //WorldState newState = new TextWorld(state);
    switch(move)
    {
      case('l'):
      {
        //newState.stacks = state.stacks;
        //newState.arm = state.arm -1;
        //newState.holding = state.holding;
        //newState.objects = state.objects;
        //newState.examples = state.examples;
        return null;
      }
      case('r'):
      {
        //state.arm++;
        return null;
      }
      case('d'):
        return null;
      case('p'):
        return null;
    }
    return null;
  }
}
