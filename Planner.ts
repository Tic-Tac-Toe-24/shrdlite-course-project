///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
///<reference path="Arrays.ts"/>

import Literal = Interpreter.Literal;
import InterpretationResult = Interpreter.InterpretationResult;

/**
 * Planner module
 *
 * The goal of the Planner module is to take the interpetation(s)
 * produced by the Interpreter module and to plan a sequence of actions
 * for the robot to put the world into a state compatible with the
 * user's command, i.e. to achieve what the user wanted.
 *
 * The planner should use your A* search implementation to find a plan.
 */
module Planner {

  ////////////////////////////////////////////////////////////////////////////
  //            Exported functions, classes and interfaces/types            //
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Top-level driver for the Planner. Calls `planInterpretation` for each given
   * interpretation generated by the Interpreter.
   * @param  {InterpretationResult[]} interpretations list of possible
   *                                                  interpretations
   * @param  {WorldState}             currentState    the current state of the
   *                                                  world
   * @return {PlannerResult[]}                        augments
   *         																					InterpretationResult with
   *         																					a plan represented by a
   *         																					list of strings
   */
  export function plan(
    interpretations : InterpretationResult[],
    currentState : WorldState
  ) : PlannerResult[] {
    let errors : Error[] = [];
    let plans : PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        let result : PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch(err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan : string[];
  }

  export function stringify(result : PlannerResult) : string {
    return result.plan.join(", ");
  }

  ////////////////////////////////////////////////////////////////////////////
  //                           Private functions                            //
  ////////////////////////////////////////////////////////////////////////////

  /**
   * Represents a node in a StateGraph. A StateNode has the arms position, what the arm is holding and the stacks of objects
   * for this state.
   */
  class StateNode {

    arm : number;
    holding : string;
    stacks : string[][];

    private strForm : string;

    /**
     * Constructs a new StateNode.
     * @param  {number}     arm  the position of the arm
     * @param  {string}     holding what the arm is holding
     * @param  {string}     stacks the stacks of objects
     */
    constructor (arm : number, holding : string, stacks : string[][]) {
      this.arm = arm;
      this.holding = holding;
      this.stacks = stacks;
      this.strForm = JSON.stringify(this);
    }

    /**
     * Indicates whether the node is a goal node (i.e. the given interpretation
     * holds in its world state).
     * @param  {DNFFormula} interpretation the interpretation
     * @return {boolean}                   true if the node is a goal node,
     *                                     false otherwise
     */

    isGoal(interpretation: DNFFormula): boolean {
      return anyValue(interpretation, conjunction =>
          allValues(conjunction, literal =>
              this.literalHolds(literal)));
    }

      /**
    * Indicates whether a given literal holds in a given world state.
    * @param  {Literal}    literal the literal
    * @return {boolean}            true if the literal holds, false otherwise
    */
    private literalHolds(literal: Literal): boolean {
      switch (literal.relation) {
        case 'holding':
          return this.holding == literal.args[0];
        case 'ontop':
          if (literal.args[1] == 'floor') {
            for (let stack of this.stacks)
              if (stack.indexOf(literal.args[0]) == 0)
                return true;
            return false;
          }

          for (let stack of this.stacks)
            if (stack.indexOf(literal.args[0])
                == stack.indexOf(literal.args[1]) + 1 && stack.indexOf(literal.args[0]) > -1 && stack.indexOf(literal.args[1]) > -1)
              return true;
          return false;
        case 'inside':
          // Same as 'ontop' since it is already checked by the interpreter
          for (let stack of this.stacks)
            if (stack.indexOf(literal.args[0])
                == stack.indexOf(literal.args[1]) + 1 && stack.indexOf(literal.args[0]) > -1 && stack.indexOf(literal.args[1]) > -1)
              return true;
          return false;
        case 'above':
          if (literal.args[1] == 'floor')
            return true;
          for (let stack of this.stacks)
            if (stack.indexOf(literal.args[0]) > stack.indexOf(literal.args[1]) && stack.indexOf(literal.args[1]) > -1)
              return true;
          return false;
        case 'under':
          for (let stack of this.stacks)
            if (stack.indexOf(literal.args[0]) < stack.indexOf(literal.args[1]) && stack.indexOf(literal.args[0]) > -1)
              return true;
          return false;
        case 'beside':
          for (let x = 0; x < this.stacks.length; x++)
            if (this.stacks[x].indexOf(literal.args[0]) > -1)
              return (x >= 1
                      && this.stacks[x - 1].indexOf(literal.args[1]) > -1)
                  || (x < this.stacks.length - 1
                      && this.stacks[x + 1].indexOf(literal.args[1]) > -1)
          return false;
        case 'leftof':
          for (let x = 0; x < this.stacks.length; x++)
            if (this.stacks[x].indexOf(literal.args[0]) > -1)
              for (let x2 = x + 1; x2 < this.stacks.length; x2++)
                if (this.stacks[x2].indexOf(literal.args[1]) > -1)
                  return true;
          return false;
        case 'rightof':
          for (let x = 0; x < this.stacks.length; x++)
            if (this.stacks[x].indexOf(literal.args[0]) > -1)
              for (let x2 = x - 1; x2 >= 0; x2--)
                if (this.stacks[x2].indexOf(literal.args[1]) > -1)
                  return true;
          return false;
      }
      return false;
    }

    /**
     * Returns a heuristic for the node using a given interpretation. In order
     * to compute the heuristic, the function computes all possible heuristics
     * for all possible conjunctions and gets the lowest one (so that it is
     * never greater than the actual cost).
     * @param  {DNFFormula} interpretation the interpretation
     * @return {number}                    the heuristic
     */
    heuristics(interpretation: DNFFormula): number {
      return Math.min.apply(null, interpretation.map(conjunction =>
          Math.max.apply(null, conjunction.map(literal =>
              this.estimatedCostLiteral(literal)))));
    }

    /**
     * Returns the estimate cost of a given literal. The estimate cost is
     * computed using the distance of the object and potentially the target from
     * the arm. The number of objects above the object to move/take might also
     * be used as well as the number of objects above the target.
     * @param  {Literal}    literal the literal
     * @return {number}             an estimation of the cost to move/take an
     *                              object
     */
    private estimatedCostLiteral(literal: Literal): number {
      if (this.literalHolds(literal))
        return 0;

      let holdingCost: number = (this.holding == null) ? 1 : 2

      if (literal.relation == 'holding') {
        return holdingCost
            + this.distanceFromArm(literal.args[0], null);
      } else {
        if (literal.relation == 'ontop' || literal.relation == 'inside') {
          return holdingCost
              + (this.objectsAbove(literal.args[0], literal.args[1]) * 3)
              + this.distanceFromArm(literal.args[0], literal.args[1]);
        } else if (literal.relation == 'above') {
          return holdingCost
              + (this.objectsAbove(literal.args[0], null) * 3)
              + this.distanceFromArm(literal.args[0], literal.args[1]);
        } else if (literal.relation == 'under') {
          return (holdingCost == 1 ? 6 : 8)
              + (this.objectsAbove(literal.args[0], literal.args[1]) * 3)
              + this.distanceFromArm(literal.args[0], literal.args[1]);
        } else if (literal.relation == 'beside') {
          return holdingCost
              + (this.objectsAbove(literal.args[0], null) * 3)
              + this.distanceFromArm(literal.args[0], literal.args[1]) - 1;
        } else if (literal.relation == 'leftof') {
          return holdingCost
              + (this.objectsAbove(literal.args[0], null) * 3)
              + this.distanceFromArm(literal.args[0], null)
              + Math.abs(
                  this.getPositions(literal.args[0], literal.args[1])[2] + 1 - this.arm);
        } else if (literal.relation == 'rightof') {
          return holdingCost
              + (this.objectsAbove(literal.args[0], null) * 3)
              + this.distanceFromArm(literal.args[0], null)
              + Math.abs(
                  this.getPositions(literal.args[0], literal.args[1])[2] - 1 - this.arm);
        }
      }

      return 0;
    }

    /**
     * Returns the position of a given object in a given world state.
     * @param  {string}     objectId the object
     * @return {number[]}            a list containing two elements: a stack index
     *                               and a position in a stack
     */
    private getPositions(firstObject: string, secondObject: string): number[] {
      if (firstObject == this.holding) {
        if (secondObject == 'floor')
          return [this.arm, this.stacks[this.arm].length, this.arm, -1]

        let positionSecondObject: number[] =
            this.getPositions(secondObject, null);

        return [this.arm, this.stacks[this.arm].length,
            positionSecondObject[0], positionSecondObject[1]];
      }

      for (let x = 0; x < this.stacks.length; x++) {
        let y: number = this.stacks[x].indexOf(firstObject);

        if (y > -1) {
          if (secondObject == null)
            return [x, y, this.arm, this.stacks[this.arm].length - 1];
          if (secondObject == 'floor')
            return [x, y, x, -1];
          if (secondObject == this.holding)
            return [x, y, this.arm, this.stacks[this.arm].length];

          for (let x2 = 0; x2 < this.stacks.length; x2++) {
            let y2: number = this.stacks[x].indexOf(firstObject);

            if (y2 > -1)
              return [x, y, x2, y2];
          }
        }
      }

      throw Error("ERROR: Object '" + firstObject + "' does not exist.");
    }

    /**
     * Returns the distance of a given object from the arm in the given world
     * state.
     * @param  {string}     objectId the object
     * @return {number}              the distance of the object from the arm
     */
    private distanceFromArm(firstObject: string, secondObject: string): number {
      let positions: number[] = this.getPositions(firstObject, secondObject);

      return Math.abs(positions[0] - this.arm)
          + Math.abs(positions[2] - this.arm);
    }

    /**
     * Returns the number of objects above a given object in the repressented world state.
     * @param  {string}     objectId the object
     * @return {number}              the number of objects above the object
     */
    private objectsAbove(firstObject: string, secondObject: string): number {
      let positions: number[] = this.getPositions(firstObject, secondObject);

      return (this.stacks[positions[0]].length - positions[1] - 1)
          + (this.stacks[positions[2]].length - positions[3] - 1);

    }

    /**
     * Compares this StateNode with the given StateNode.
     * @param  {StateNode}     other the given StateNode
     * @return {number}              the number symbolizing whether the are the same or not.
     */
    compareTo(other: StateNode): number {
      if (this.strForm === other.strForm)
        return 0;
      return 100;
    }

    /**
     * Returns the string version of the StateNode.
     * @return {string}   this StateNode in string form.
     */
    toString(): string {
      return this.strForm;
    }
  }

  /**
   * Represents the graph used by the search algorithm.
   * The graph is build on the fly by the search algorithm.
   * Contains the objects definitions.
   */
  class StateGraph implements Graph<StateNode> {

    objects : {[s:string] : ObjectDefinition}

    /**
     * Constructs a new StateGraph.
     * @param  {WorldState}   state  The state containing the ObjectDefinitions
     */
    constructor(state : WorldState) {
      this.objects = state.objects;
    }


    /**
     * Returns the outgoing edges of a given node in the graph.
     * @param  {StateNode}       node the node
     * @return {Edge<StateNode>}      the edges
     */
    outgoingEdges(node: StateNode): Edge<StateNode>[] {
      let edges: Edge<StateNode>[] = [];

      if (node.holding == null && node.stacks[node.arm].length > 0) {
        var stacks : string[][] = this.copyStacks(node);
        var holding : string = stacks[node.arm].pop();
        edges.push(this.newEdge(1, node, new StateNode(node.arm, holding, stacks)));
      }
      if (this.canDrop(node)) {
        var stacks : string[][] = this.copyStacks(node);
        stacks[node.arm].push(node.holding);
        edges.push(this.newEdge(1, node, new StateNode(node.arm, null, stacks)));
      }
      if (node.arm > 0) {
        edges.push(this.newEdge(1, node, new StateNode(node.arm-1,node.holding,this.copyStacks(node))));
      }
      if (node.arm < node.stacks.length-1) {
        edges.push(this.newEdge(1, node, new StateNode(node.arm+1, node.holding, this.copyStacks(node))));
      }

      return edges;
    }

    /**
     * Indicates whether the arm of a given world state can drop the object it
     * holds.
     * @return {boolean}          true if the arm can drop the object, false
     *                            otherwise
     */
    private canDrop(node : StateNode): boolean {
      if (node.holding == null)
        return false;

      let objectHeld = this.objects[node.holding];
      let stackUnderArm: string[] = node.stacks[node.arm];
      let objectOnTopOfStack =
          this.objects[stackUnderArm[stackUnderArm.length - 1]];

      // Anything can be dropped on the floor.
      if(stackUnderArm.length != 0) {
        // Balls must be in boxes or on the floor, otherwise they roll away.
        if (objectHeld.form == 'ball' && objectOnTopOfStack.form != 'box')
          return false;
        // Balls cannot support anything.
        if (stackUnderArm.length > 0 && objectOnTopOfStack.form == 'ball')
          return false;
        // Small objects cannot support large objects.
        if (objectOnTopOfStack.size == 'small' && objectHeld.size == 'large')
          return false;
        // Boxes cannot contain pyramids, planks or boxes of the same size.
        if (objectOnTopOfStack.form == 'box'
            && objectOnTopOfStack.size == objectHeld.size
            && (objectHeld.form == 'pyramid' || objectHeld.form == 'plank'
                || objectHeld.form == 'box'))
          return false;
        // Small boxes cannot be supported by small bricks or pyramids.
        if (objectHeld.form == 'box' && objectHeld.size == 'small'
            && objectOnTopOfStack.size == 'small'
            && (objectOnTopOfStack.form == 'brick'
                || objectOnTopOfStack.form == 'pyramid'))
          return false;
        // Large boxes cannot be supported by large pyramids.
        if (objectHeld.form == 'box' && objectHeld.size == 'large'
            && objectOnTopOfStack.form == 'pyramid'
            && objectOnTopOfStack.size == 'large')
          return false;
      }
      return true;
    }

    private newEdge(cost : number, from : StateNode, to : StateNode) : Edge<StateNode> {
      var edge : Edge<StateNode> = new Edge<StateNode>();
      edge.cost = cost;
      edge.from = from;
      edge.to = to;
      return edge;
    }

    /**
     * Returns a new set of stacks identical to given StateNodes.
     * @param  {StateNode}     node  the StateNode
     * @return {string[][]}          the new stacks
     */
    private copyStacks(node: StateNode): string[][] {
      let newStacks: string[][] = [];

      for (let stack of node.stacks) {
        let newStack: string[] = [];

        for (let object of stack)
          newStack.push(object);

        newStacks.push(newStack);
      }
      return newStacks;
    }

    /**
     * Compares two StateNodes.
     * @param  {StateNode}     first  the first StateNode
     * @param  {StateNode}     second the second StateNode
     * @return {number}               number representing the difference between them (0 or 100).
     */
    compareNodes: ICompareFunction<StateNode> = function (first, second) {
      return first.compareTo(second);
    }
  }

  /**
   * The core planner function. It simply runs the A* search algorithm on a
   * StateGraph.
   * @param  {DNFFormula} interpretation the logical interpretation of the
   *                                     user's desired goal. The plan needs to
   *                                     be such that by executing it, the world
   *                                     is put into a state that satisfies this
   *                                     goal.
   * @param  {WorldState} state          the current world state
   * @return {string[]}                  the list of actions the robot should
   *                                     perform
   */
  function planInterpretation(
    interpretation: DNFFormula,
    state: WorldState
  ): string[] {
    var time = -Date.now();

    if(new StateNode(state.arm,state.holding,state.stacks).isGoal(interpretation)) {
        return [];
    }

    var error : Error;
    var result : SearchResult<StateNode>;
    try {
      let newResult: SearchResult<StateNode> = aStarSearch(
        new StateGraph(state),
        new StateNode(state.arm,state.holding,state.stacks),
        node => node.isGoal(interpretation),
        node => node.heuristics(interpretation),
        5
      );
      if(result == null || newResult.cost < result.cost) {
        result = newResult;
      }
    } catch(err) {
      error = err;
    }

    let actions: string[] = [];

    if(result != null) {
      for(var n = 0; n < result.path.length-1; n++)
        actions.push(action(result.path[n], result.path[n+1]));
    } else if(error != null) {
      var err : string = error.message + " :";
      for(var a of interpretation) {
        err += '\n';
        for(var b of a) {
          err += " " + b.relation + "(" + b.args + ")";
        }
      }
      throw Error(err);
    }
    actions.push("Time: " + (time + Date.now()));
    return actions;
  }
  /**
   * Finds the actions to perform to go between two StateNodes.
   * @param  {StateNode}  from  the StateNode to move from
   * @param  {StateNode}  to    the StateNode to move to
   * @return {string}           the action needed to be performed
   */
  function action(from : StateNode, to : StateNode) : string {
    if(from.holding == null && to.holding != null) {
      return "p";
    } else if(from.holding != null && to.holding == null) {
      return "d";
    } else if(from.arm > to.arm) {
      return "l";
    } else if(from.arm < to.arm) {
      return "r";
    }
      return null;
  }
}
